<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LUKA | FIXED</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.158.0/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<style>
body { margin:0; background:#000; overflow:hidden; }
canvas { display:block; }
</style>
</head>
<body>

<script>

let scene, camera, renderer;
let ballGroup, fragments = [];
let isResumed = false;

const rows = 12;
const cols = 10;
const fragCount = rows * cols;

const loader = new THREE.TextureLoader();
const resumeTex = loader.load('resume_front.jpg');
const backTex   = loader.load('resume_back.jpg');

init();
animate();

function init() {

scene = new THREE.Scene();

camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.z = 14;

renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 0.6));

ballGroup = new THREE.Group();
scene.add(ballGroup);

/* -------- IMAGE DIMENSIONS -------- */

const imageRatio = 1650 / 1275; // YOUR ACTUAL IMAGE RATIO

const totalWidth = 10;
const totalHeight = totalWidth * imageRatio;

const fragWidth = totalWidth / cols;
const fragHeight = totalHeight / rows;

/* -------- CRITICAL FIX -------- */
/* We use repeat + offset instead of editing UVs */

resumeTex.wrapS = THREE.ClampToEdgeWrapping;
resumeTex.wrapT = THREE.ClampToEdgeWrapping;

backTex.wrapS = THREE.ClampToEdgeWrapping;
backTex.wrapT = THREE.ClampToEdgeWrapping;

for (let v = 0; v < rows; v++) {
for (let u = 0; u < cols; u++) {

    const fragContainer = new THREE.Group();

    /* ---------- FRONT ---------- */

    const frontTex = resumeTex.clone();
    frontTex.repeat.set(1/cols, 1/rows);
    frontTex.offset.set(u/cols, 1 - (v+1)/rows);

    const meshFront = new THREE.Mesh(
        new THREE.PlaneGeometry(fragWidth, fragHeight),
        new THREE.MeshStandardMaterial({ map: frontTex })
    );

    /* ---------- BACK ---------- */

    const backTextureClone = backTex.clone();
    backTextureClone.repeat.set(-1/cols, 1/rows);   // mirror horizontally
    backTextureClone.offset.set((u+1)/cols, 1 - (v+1)/rows);

    const meshBack = new THREE.Mesh(
        new THREE.PlaneGeometry(fragWidth, fragHeight),
        new THREE.MeshStandardMaterial({ map: backTextureClone })
    );

    meshBack.rotation.y = Math.PI;
    meshBack.position.z = -0.01;

    fragContainer.add(meshFront);
    fragContainer.add(meshBack);

    /* -------- START AS BALL -------- */

    const i = v * cols + u;
    const phi = Math.acos(-1 + (2 * i) / fragCount);
    const theta = Math.sqrt(fragCount * Math.PI) * phi;

    fragContainer.position.setFromSphericalCoords(4, phi, theta);
    fragContainer.lookAt(0,0,0);

    /* -------- PERFECT CENTERED GRID -------- */

    fragContainer.userData = {
        homeX: (u - cols/2 + 0.5) * fragWidth,
        homeY: (rows/2 - v - 0.5) * fragHeight
    };

    fragments.push(fragContainer);
    ballGroup.add(fragContainer);
}
}

ballGroup.position.z = -30;

window.addEventListener('click', unfold);

window.addEventListener('resize', onResize);
}

function unfold() {

if (isResumed) return;
isResumed = true;

fragments.forEach((f, i) => {

    gsap.to(f.position, {
        x: f.userData.homeX,
        y: f.userData.homeY,
        z: 0,
        duration: 1.8,
        delay: i * 0.002,
        ease: "expo.inOut"
    });

    gsap.to(f.rotation, {
        x: 0,
        y: 0,
        z: 0,
        duration: 1.8,
        ease: "expo.inOut"
    });

});

gsap.to(ballGroup.position, { z: -8, duration: 2 });
gsap.to(ballGroup.rotation, { x:0, y:0, z:0, duration:2 });

}

function animate() {
requestAnimationFrame(animate);

if (!isResumed) {
    ballGroup.rotation.y += 0.01;
    ballGroup.rotation.x += 0.005;
}

renderer.render(scene, camera);
}

function onResize(){
camera.aspect = window.innerWidth/window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth, window.innerHeight);
}

</script>
</body>
</html>
