<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LUKA | FULL FIX</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.158.0/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

<style>
body { margin:0; background:#000; overflow:hidden; }
canvas { display:block; }
</style>
</head>
<body>

<script>

let scene, camera, renderer;
let ballGroup, fragments = [];
let rows = 12, cols = 10;
let isUnfolded = false;

const loader = new THREE.TextureLoader();

Promise.all([
    loader.loadAsync("resume_front.jpg"),
    loader.loadAsync("resume_back.jpg")
]).then(([frontTex, backTex]) => {

init(frontTex, backTex);
animate();

});

function init(frontTex, backTex){

scene = new THREE.Scene();

camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
);
camera.position.z = 14;

renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 0.8));

ballGroup = new THREE.Group();
scene.add(ballGroup);

/* ---------- READ REAL IMAGE SIZE ---------- */

const imgW = frontTex.image.width;
const imgH = frontTex.image.height;
const ratio = imgH / imgW;

/* ---------- SHEET SIZE ---------- */

const totalWidth = 10;
const totalHeight = totalWidth * ratio;

const fragW = totalWidth / cols;
const fragH = totalHeight / rows;

/* ---------- BUILD FRAGMENTS ---------- */

let index = 0;

for(let y=0; y<rows; y++){
for(let x=0; x<cols; x++){

    const container = new THREE.Group();

    /* FRONT */

    const geoFront = new THREE.PlaneGeometry(fragW, fragH);

    const uvF = geoFront.attributes.uv;
    for(let i=0;i<uvF.count;i++){
        const u = (uvF.getX(i) + x) / cols;
        const v = (uvF.getY(i) + (rows - y - 1)) / rows;
        uvF.setXY(i, u, v);
    }

    const frontMesh = new THREE.Mesh(
        geoFront,
        new THREE.MeshBasicMaterial({ map: frontTex })
    );

    /* BACK */

    const geoBack = new THREE.PlaneGeometry(fragW, fragH);
    const uvB = geoBack.attributes.uv;

    for(let i=0;i<uvB.count;i++){
        const u = 1 - ((uvB.getX(i) + x) / cols); // mirror
        const v = (uvB.getY(i) + (rows - y - 1)) / rows;
        uvB.setXY(i, u, v);
    }

    const backMesh = new THREE.Mesh(
        geoBack,
        new THREE.MeshBasicMaterial({ map: backTex })
    );

    backMesh.rotation.y = Math.PI;
    backMesh.position.z = -0.01;

    container.add(frontMesh);
    container.add(backMesh);

    /* SPHERE POSITION */

    const phi = Math.acos(-1 + (2 * index) / (rows*cols));
    const theta = Math.sqrt(rows*cols * Math.PI) * phi;

    container.position.setFromSphericalCoords(4, phi, theta);
    container.lookAt(0,0,0);

    /* PERFECT CENTER GRID */

    container.userData = {
        homeX: (x - cols/2 + 0.5) * fragW,
        homeY: (rows/2 - y - 0.5) * fragH
    };

    fragments.push(container);
    ballGroup.add(container);

    index++;
}}

ballGroup.position.z = -25;

window.addEventListener("click", unfold);
window.addEventListener("resize", onResize);
}

function unfold(){

if(isUnfolded) return;
isUnfolded = true;

fragments.forEach((f,i)=>{

    gsap.to(f.position,{
        x:f.userData.homeX,
        y:f.userData.homeY,
        z:0,
        duration:1.8,
        delay:i*0.002,
        ease:"expo.inOut"
    });

    gsap.to(f.rotation,{
        x:0,y:0,z:0,
        duration:1.8,
        ease:"expo.inOut"
    });

});

gsap.to(ballGroup.position,{ z:-8, duration:2 });
gsap.to(ballGroup.rotation,{ x:0,y:0,z:0, duration:2 });

}

function animate(){
requestAnimationFrame(animate);

if(!isUnfolded){
    ballGroup.rotation.y += 0.01;
    ballGroup.rotation.x += 0.005;
}

renderer.render(scene,camera);
}

function onResize(){
camera.aspect = window.innerWidth/window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth,window.innerHeight);
}

</script>
</body>
</html>
